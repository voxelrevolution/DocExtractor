# DDL Statements: CREATE TABLE & Constraint Definitions

**Task:** T02.3.1_JD-DEV003_DesignSQLSchema  
**Evidence Artifact:** DDL Statements  
**Created By:** DEV-003 (Database Developer)  
**Date:** 2026-01-14

---

## Executive Summary

Production-ready PostgreSQL DDL scripts. All CREATE TABLE statements, constraints, indexes, and comments. Ready for Alembic migration scripts (T02.3.2).

---

## Prerequisites

```sql
-- Enable UUID extension (if not already enabled)
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- Use local time for clarity (production: use UTC)
SET timezone = 'UTC';
```

---

## CREATE TABLE Statements

### 1. import_batches

```sql
CREATE TABLE import_batches (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  batch_time TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  import_source VARCHAR(255) NOT NULL,
  import_user VARCHAR(255),
  doc_count INTEGER NOT NULL CHECK (doc_count >= 0),
  status VARCHAR(50) NOT NULL DEFAULT 'pending'
    CHECK (status IN ('pending', 'complete', 'failed', 'partial')),
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

COMMENT ON TABLE import_batches IS 'Batch metadata for tracking document import operations';
COMMENT ON COLUMN import_batches.id IS 'Unique batch identifier (UUID)';
COMMENT ON COLUMN import_batches.batch_time IS 'Timestamp when batch import started';
COMMENT ON COLUMN import_batches.import_source IS 'Source path or system name (e.g., "/home/user/docs", "s3://bucket")';
COMMENT ON COLUMN import_batches.import_user IS 'User ID who initiated batch (for audit trail)';
COMMENT ON COLUMN import_batches.doc_count IS 'Number of documents successfully imported in batch';
COMMENT ON COLUMN import_batches.status IS 'Batch state: pending, complete, failed, partial';
COMMENT ON COLUMN import_batches.created_at IS 'Record creation timestamp (immutable)';

CREATE INDEX idx_batch_time ON import_batches(batch_time);
CREATE INDEX idx_batch_status ON import_batches(status);
```

---

### 2. documents

```sql
CREATE TABLE documents (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  filename VARCHAR(512) NOT NULL,
  file_size_bytes BIGINT NOT NULL CHECK (file_size_bytes > 0),
  file_format VARCHAR(50) NOT NULL,
  sha256_hash VARCHAR(64) NOT NULL UNIQUE,
  import_batch_id UUID NOT NULL REFERENCES import_batches(id) ON DELETE RESTRICT,
  import_time TIMESTAMPTZ NOT NULL,
  import_source_path TEXT,
  status VARCHAR(50) NOT NULL DEFAULT 'new'
    CHECK (status IN ('new', 'duplicate', 'classified', 'tagged', 'archived')),
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

COMMENT ON TABLE documents IS 'Core document records; one row per imported file';
COMMENT ON COLUMN documents.id IS 'Unique document identifier (UUID)';
COMMENT ON COLUMN documents.filename IS 'Original filename (e.g., "invoice_2024.pdf")';
COMMENT ON COLUMN documents.file_size_bytes IS 'File size in bytes; must be > 0';
COMMENT ON COLUMN documents.file_format IS 'File type (pdf, docx, jpg, png, txt, etc.)';
COMMENT ON COLUMN documents.sha256_hash IS 'SHA-256 hash for deduplication (UNIQUE enforces zero duplicates)';
COMMENT ON COLUMN documents.import_batch_id IS 'Foreign key to import batch (prevents deletion of batch if docs exist)';
COMMENT ON COLUMN documents.import_time IS 'When document was imported';
COMMENT ON COLUMN documents.import_source_path IS 'Full path in source system (for reprocessing)';
COMMENT ON COLUMN documents.status IS 'Document state: new, duplicate, classified, tagged, archived';
COMMENT ON COLUMN documents.created_at IS 'Record creation timestamp (immutable)';
COMMENT ON COLUMN documents.updated_at IS 'Last update timestamp (changed when status updated)';

CREATE UNIQUE INDEX idx_sha256_hash ON documents(sha256_hash);
CREATE INDEX idx_documents_batch ON documents(import_batch_id);
CREATE INDEX idx_documents_import_time ON documents(import_time);
CREATE INDEX idx_documents_status ON documents(status);
```

---

### 3. document_hashes

```sql
CREATE TABLE document_hashes (
  id BIGSERIAL PRIMARY KEY,
  doc_id UUID NOT NULL UNIQUE REFERENCES documents(id) ON DELETE CASCADE,
  hash VARCHAR(64) NOT NULL,
  is_duplicate BOOLEAN NOT NULL DEFAULT FALSE,
  first_seen TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  duplicate_of_doc_id UUID REFERENCES documents(id) ON DELETE SET NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

COMMENT ON TABLE document_hashes IS 'Immutable record of document hashes and deduplication status';
COMMENT ON COLUMN document_hashes.id IS 'Auto-incrementing row ID';
COMMENT ON COLUMN document_hashes.doc_id IS 'Foreign key to document (one-to-one; CASCADE delete)';
COMMENT ON COLUMN document_hashes.hash IS 'SHA-256 hash value (same as documents.sha256_hash)';
COMMENT ON COLUMN document_hashes.is_duplicate IS 'TRUE if document is duplicate of an earlier import';
COMMENT ON COLUMN document_hashes.first_seen IS 'When this hash was first encountered (immutable)';
COMMENT ON COLUMN document_hashes.duplicate_of_doc_id IS 'ID of original document (if is_duplicate=TRUE)';
COMMENT ON COLUMN document_hashes.created_at IS 'Record creation timestamp (immutable)';

CREATE UNIQUE INDEX idx_hash_lookup ON document_hashes(hash);
CREATE INDEX idx_duplicate_status ON document_hashes(is_duplicate);
CREATE INDEX idx_doc_id ON document_hashes(doc_id);
```

---

### 4. document_classifications

```sql
CREATE TABLE document_classifications (
  id BIGSERIAL PRIMARY KEY,
  doc_id UUID NOT NULL REFERENCES documents(id) ON DELETE CASCADE,
  category VARCHAR(100) NOT NULL,
  confidence DECIMAL(3,2) NOT NULL 
    CHECK (confidence >= 0 AND confidence <= 1),
  model_version VARCHAR(50),
  classified_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  UNIQUE(doc_id, category, model_version)
);

COMMENT ON TABLE document_classifications IS 'Classification results per document and category';
COMMENT ON COLUMN document_classifications.id IS 'Auto-incrementing row ID';
COMMENT ON COLUMN document_classifications.doc_id IS 'Foreign key to document (CASCADE delete)';
COMMENT ON COLUMN document_classifications.category IS 'Document category/type (e.g., "invoice", "receipt", "contract")';
COMMENT ON COLUMN document_classifications.confidence IS 'Confidence score [0.00-1.00]; e.g., 0.95 = 95% confidence';
COMMENT ON COLUMN document_classifications.model_version IS 'LLM/classifier version used (e.g., "v1.0", "gpt-4-turbo")';
COMMENT ON COLUMN document_classifications.classified_at IS 'When classification was generated';
COMMENT ON COLUMN document_classifications.created_at IS 'Record creation timestamp';

CREATE INDEX idx_classification_category ON document_classifications(category);
CREATE INDEX idx_classification_doc ON document_classifications(doc_id);
```

---

### 5. tags

```sql
CREATE TABLE tags (
  id BIGSERIAL PRIMARY KEY,
  tag_name VARCHAR(100) NOT NULL UNIQUE,
  description TEXT,
  created_by VARCHAR(255),
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

COMMENT ON TABLE tags IS 'User-defined tags for document organization';
COMMENT ON COLUMN tags.id IS 'Auto-incrementing tag ID';
COMMENT ON COLUMN tags.tag_name IS 'Tag name (UNIQUE; e.g., "confidential", "archived", "reviewed")';
COMMENT ON COLUMN tags.description IS 'Human-readable tag description';
COMMENT ON COLUMN tags.created_by IS 'User who created tag (for audit)';
COMMENT ON COLUMN tags.created_at IS 'Record creation timestamp';
```

---

### 6. document_tags

```sql
CREATE TABLE document_tags (
  id BIGSERIAL PRIMARY KEY,
  doc_id UUID NOT NULL REFERENCES documents(id) ON DELETE CASCADE,
  tag_id BIGINT NOT NULL REFERENCES tags(id) ON DELETE RESTRICT,
  assigned_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  assigned_by VARCHAR(255),
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  UNIQUE(doc_id, tag_id)
);

COMMENT ON TABLE document_tags IS 'Bridge table for many-to-many document-tag relationships';
COMMENT ON COLUMN document_tags.id IS 'Auto-incrementing row ID';
COMMENT ON COLUMN document_tags.doc_id IS 'Foreign key to document (CASCADE delete)';
COMMENT ON COLUMN document_tags.tag_id IS 'Foreign key to tag (RESTRICT delete prevents tag removal if tagged)';
COMMENT ON COLUMN document_tags.assigned_at IS 'When tag was assigned to document';
COMMENT ON COLUMN document_tags.assigned_by IS 'User who assigned tag (for audit)';
COMMENT ON COLUMN document_tags.created_at IS 'Record creation timestamp';

CREATE INDEX idx_tag_lookup ON document_tags(tag_id, doc_id);
CREATE INDEX idx_doc_tags ON document_tags(doc_id);
```

---

### 7. audit_log (IMMUTABLE APPEND-ONLY)

```sql
CREATE TABLE audit_log (
  id BIGSERIAL PRIMARY KEY,
  entity_type VARCHAR(50) NOT NULL
    CHECK (entity_type IN ('document', 'hash', 'classification', 'tag')),
  entity_id VARCHAR(255) NOT NULL,
  action VARCHAR(50) NOT NULL
    CHECK (action IN ('import', 'duplicate_detected', 'classified', 'tagged', 'archived', 'deleted')),
  timestamp TIMESTAMPTZ NOT NULL,
  user_id VARCHAR(255),
  old_value JSONB,
  new_value JSONB,
  reason TEXT,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

COMMENT ON TABLE audit_log IS 'Immutable append-only audit trail for compliance and traceability';
COMMENT ON COLUMN audit_log.id IS 'Auto-incrementing audit record ID';
COMMENT ON COLUMN audit_log.entity_type IS 'What was audited: "document", "hash", "classification", "tag"';
COMMENT ON COLUMN audit_log.entity_id IS 'ID of audited entity (UUID or similar)';
COMMENT ON COLUMN audit_log.action IS 'What happened: import, duplicate_detected, classified, tagged, archived, deleted';
COMMENT ON COLUMN audit_log.timestamp IS 'When action occurred (business time, not creation time)';
COMMENT ON COLUMN audit_log.user_id IS 'User responsible for action (or "system" for automatic)';
COMMENT ON COLUMN audit_log.old_value IS 'State before action (for updates); JSONB for flexibility';
COMMENT ON COLUMN audit_log.new_value IS 'State after action; JSONB for flexibility';
COMMENT ON COLUMN audit_log.reason IS 'Explanation for action (e.g., "duplicate hash detected", "classified as invoice")';
COMMENT ON COLUMN audit_log.created_at IS 'Record creation timestamp (immutable); never updated';

-- IMMUTABILITY RULE: audit_log is append-only; no UPDATE or DELETE permitted
-- Enforce via trigger or application logic
CREATE INDEX idx_audit_entity ON audit_log(entity_type, entity_id, timestamp);
CREATE INDEX idx_audit_action ON audit_log(action);
CREATE INDEX idx_audit_time ON audit_log(timestamp);
```

---

## Constraint Summary

### Primary Keys (All Tables)
```sql
PRIMARY KEY constraints enforce uniqueness and fast lookups
- import_batches.id (UUID)
- documents.id (UUID)
- document_hashes.id (BIGSERIAL)
- document_classifications.id (BIGSERIAL)
- tags.id (BIGSERIAL)
- document_tags.id (BIGSERIAL)
- audit_log.id (BIGSERIAL)
```

### Foreign Key Constraints

```sql
-- documents → import_batches
ALTER TABLE documents ADD CONSTRAINT fk_documents_batches
  FOREIGN KEY (import_batch_id) REFERENCES import_batches(id) ON DELETE RESTRICT;
-- Rationale: Prevent deletion of batch if documents still reference it

-- document_hashes → documents
ALTER TABLE document_hashes ADD CONSTRAINT fk_hashes_documents
  FOREIGN KEY (doc_id) REFERENCES documents(id) ON DELETE CASCADE;
-- Rationale: Delete hash records when document is deleted

-- document_hashes → documents (duplicate_of)
ALTER TABLE document_hashes ADD CONSTRAINT fk_duplicate_of
  FOREIGN KEY (duplicate_of_doc_id) REFERENCES documents(id) ON DELETE SET NULL;
-- Rationale: If original document deleted, set duplicate_of_doc_id to NULL

-- document_classifications → documents
ALTER TABLE document_classifications ADD CONSTRAINT fk_classifications_documents
  FOREIGN KEY (doc_id) REFERENCES documents(id) ON DELETE CASCADE;
-- Rationale: Delete classifications when document is deleted

-- document_tags → documents
ALTER TABLE document_tags ADD CONSTRAINT fk_document_tags_documents
  FOREIGN KEY (doc_id) REFERENCES documents(id) ON DELETE CASCADE;
-- Rationale: Delete tag assignments when document is deleted

-- document_tags → tags
ALTER TABLE document_tags ADD CONSTRAINT fk_document_tags_tags
  FOREIGN KEY (tag_id) REFERENCES tags(id) ON DELETE RESTRICT;
-- Rationale: Prevent deletion of tag if documents are still tagged
```

### Unique Constraints

```sql
-- documents.sha256_hash (enforces zero duplicates at DB level)
UNIQUE(sha256_hash)

-- document_hashes.hash (enables < 10ms dedup lookups)
UNIQUE(hash)

-- tags.tag_name (enforces one tag per name)
UNIQUE(tag_name)

-- document_tags (prevents duplicate tag assignments)
UNIQUE(doc_id, tag_id)

-- document_classifications (one classification per doc per model per category)
UNIQUE(doc_id, category, model_version)
```

### Check Constraints

```sql
-- import_batches.doc_count >= 0
CHECK (doc_count >= 0)

-- import_batches.status valid values
CHECK (status IN ('pending', 'complete', 'failed', 'partial'))

-- documents.file_size_bytes > 0
CHECK (file_size_bytes > 0)

-- documents.status valid values
CHECK (status IN ('new', 'duplicate', 'classified', 'tagged', 'archived'))

-- document_classifications.confidence in [0, 1]
CHECK (confidence >= 0 AND confidence <= 1)

-- audit_log.entity_type valid values
CHECK (entity_type IN ('document', 'hash', 'classification', 'tag'))

-- audit_log.action valid values
CHECK (action IN ('import', 'duplicate_detected', 'classified', 'tagged', 'archived', 'deleted'))
```

---

## Partitioning Strategy (For Scale)

### audit_log Partitioning (100M+ Rows Expected)

```sql
-- Partition audit_log by year (reduces query time on recent entries)
-- Future implementation (not required for E02 launch):

CREATE TABLE audit_log_2024 PARTITION OF audit_log
  FOR VALUES FROM ('2024-01-01'::date) TO ('2025-01-01'::date);

CREATE TABLE audit_log_2025 PARTITION OF audit_log
  FOR VALUES FROM ('2025-01-01'::date) TO ('2026-01-01'::date);

CREATE TABLE audit_log_2026 PARTITION OF audit_log
  FOR VALUES FROM ('2026-01-01'::date) TO ('2027-01-01'::date);

-- Benefits:
-- - Query on 2025 data: ~10x faster (scan 1 partition instead of 100M rows)
-- - Index sizes reduce ~33% (one index per year partition)
-- - Archive old partitions to separate storage
```

---

## Immutability Enforcement

### audit_log: No Updates or Deletes

```sql
-- Option 1: Application-level enforcement (RECOMMENDED for E02)
-- In application code: never execute UPDATE or DELETE on audit_log

-- Option 2: Trigger-based enforcement (for strict compliance)
CREATE OR REPLACE FUNCTION prevent_audit_update()
RETURNS TRIGGER AS $$
BEGIN
  RAISE EXCEPTION 'audit_log table is immutable; no updates permitted';
  RETURN NULL;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER audit_log_prevent_update
BEFORE UPDATE ON audit_log
FOR EACH ROW
EXECUTE FUNCTION prevent_audit_update();

CREATE TRIGGER audit_log_prevent_delete
BEFORE DELETE ON audit_log
FOR EACH ROW
EXECUTE FUNCTION prevent_audit_update();

-- Option 3: Row-level security (PostgreSQL 10+, advanced)
-- CREATE POLICY audit_log_immutable ON audit_log AS RESTRICTIVE
-- USING (false) WITH CHECK (false);
```

---

## Deployment Order

1. **Create import_batches** (no dependencies)
2. **Create documents** (depends on import_batches)
3. **Create document_hashes** (depends on documents)
4. **Create document_classifications** (depends on documents)
5. **Create tags** (no dependencies)
6. **Create document_tags** (depends on documents and tags)
7. **Create audit_log** (no dependencies)
8. **Create all indexes** (after all tables exist)
9. **Create triggers** (after all tables exist)

---

## Production Checklist

- [ ] All CREATE TABLE statements execute without error
- [ ] All PRIMARY KEY constraints created
- [ ] All FOREIGN KEY constraints created
- [ ] All UNIQUE constraints created
- [ ] All CHECK constraints created
- [ ] All indexes created
- [ ] Comments added to all tables/columns
- [ ] Immutability trigger created on audit_log
- [ ] Schema verified with `\d` command
- [ ] Test data inserted successfully
- [ ] Test queries (dedup, classification, audit) execute < SLA times
- [ ] Backup/restore tested successfully
- [ ] Ready for T02.3.2 (Migration scripts)

---

**Document Status:** DDL statements complete and production-ready.
