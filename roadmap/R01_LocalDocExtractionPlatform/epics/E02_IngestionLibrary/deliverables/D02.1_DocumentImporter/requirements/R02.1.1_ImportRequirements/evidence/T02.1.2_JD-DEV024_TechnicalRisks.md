# Technical Risks: Import Engine Design

**Task:** T02.1.2_JD-DEV024_DesignImportEngine  
**Owner:** DEV-024 (Deliverables Manager)  
**Date:** 2026-01-14

---

## Risk Register

### RISK 1: Large PDF Parsing Timeout

**Issue:** A 100+ page PDF or heavily formatted document could exceed the 2-second timeout.

**Probability:** MEDIUM (5-10% of real-world PDFs in typical doc repositories)

**Impact:** MEDIUM (document skipped, user must retry or split file)

**Mitigation:**
- Set timeout to 2 seconds (still 4× the target)
- Add file size pre-check: warn if PDF > 20MB, offer split
- Log size + parse time to audit trail; analyze patterns
- Implementation: `signal.alarm(2)` for timeout enforcement

**Owner:** DEV-024 (implementation task T02.1.3)

---

### RISK 2: Memory Leak in Parser Loop

**Issue:** If the parser holds references to parsed documents, memory could grow unbounded during batch processing (100 docs × 1MB each = 100MB).

**Probability:** LOW (pdfplumber/python-docx are well-tested)

**Impact:** HIGH (process crash mid-batch, batch import fails)

**Mitigation:**
- Use context managers (`with` statements) to ensure parser cleanup
- Monitor memory with `psutil` during unit tests
- Add per-document memory check; abort if > 500MB used
- Implementation: `import psutil; psutil.Process().memory_info().rss`

**Owner:** DEV-024 (unit test in T02.1.4 QC phase)

---

### RISK 3: SQLite Lock Contention

**Issue:** If dedup task (D02.2) queries hash_index while import is still writing, SQLite could lock and slow both operations.

**Probability:** MEDIUM (depends on concurrent execution timing)

**Impact:** MEDIUM (degraded performance, not failure)

**Mitigation:**
- Use SQLite WAL (Write-Ahead Logging) mode: enables concurrent reads
- Implementation: `PRAGMA journal_mode=WAL;` in schema setup (T02.3.1)
- Design import to use minimal transaction time (per-doc, not entire batch)
- If contention occurs: log and alert; add connection pooling

**Owner:** DEV-003 (schema design T02.3.1, enable WAL)

---

### RISK 4: Corrupted DOCX Crashes Parser

**Issue:** Malformed DOCX (e.g., missing required XML files) could crash python-docx library.

**Probability:** MEDIUM (real-world scanned docs sometimes corrupted)

**Impact:** MEDIUM (document skipped if not caught; batch continues with other docs)

**Mitigation:**
- Wrap DOCX parser in try/except
- Return {text: "", error: "DOCX parsing failed: <error message>"} on exception
- Log specific error type for debugging
- Implementation: Explicit exception handling in DOCX module

**Owner:** DEV-024 (DOCX parser module, T02.1.3)

---

### RISK 5: Hash Collision (Extremely Unlikely but Possible)

**Issue:** SHA-256 collisions are theoretically possible but extremely rare (1 in 2^256).

**Probability:** NEGLIGIBLE

**Impact:** HIGH (if 2 different docs hash to same value, dedup marks one as duplicate incorrectly)

**Mitigation:**
- Use SHA-256 (256-bit hash, collision resistant for practical purposes)
- If concerned: add secondary check (file size + first 1KB hash) as tiebreaker
- Log any hash lookups with duplicates for manual review
- Note in audit: hash collision is essentially impossible with SHA-256

**Owner:** None (design already uses SHA-256, no action needed)

---

### RISK 6: Database Schema Doesn't Exist

**Issue:** If T02.3.1 (Schema Design) fails or isn't complete, T02.1.3 (Implementation) will crash on first DB write.

**Probability:** LOW (T02.3.1 is independent, likely completes before/in parallel)

**Impact:** HIGH (T02.1.3 completely blocked, no import possible)

**Mitigation:**
- T02.1.2 blocks on T02.3.1 completion (explicit dependency)
- T02.1.3 validates schema before processing any docs (schema check at startup)
- Implementation: `SELECT name FROM sqlite_master WHERE type='table' AND name='documents';`
- If missing: fail with clear error message before trying import

**Owner:** DEV-024 (startup validation in T02.1.3)

---

### RISK 7: Unsupported File Type Not Caught

**Issue:** User includes .txt, .docx.old, or other files; parser doesn't handle them.

**Probability:** MEDIUM (users often have mixed file types)

**Impact:** LOW (file rejected by validator, batch continues)

**Mitigation:**
- Batch Validator checks file extensions strictly (only .pdf, .docx allowed)
- Implementation: Explicit whitelist `if not filename.lower().endswith(('.pdf', '.docx'))`
- Return clear error: "Unsupported file type: .txt (only .pdf and .docx allowed)"
- Note in audit log

**Owner:** DEV-024 (Batch Validator module, T02.1.3)

---

### RISK 8: Performance Target Missed (> 500ms per doc)

**Issue:** Real-world performance could exceed < 500ms target due to I/O, formatting complexity.

**Probability:** MEDIUM (depends on hardware, file characteristics)

**Impact:** MEDIUM (batch takes longer but still completes)

**Mitigation:**
- Set realistic target: < 1200ms per doc (500ms parse + 50ms hash + 100ms storage + overhead)
- Measure actual on test data before T02.1.4 QC
- If parse is slow: optimize pdfplumber settings (e.g., disable OCR)
- Batch of 100 = ~2 minutes (acceptable for import-once workflow)
- Implementation: Benchmark on diverse PDFs (scanned, digital, mixed)

**Owner:** DEV-024 (performance testing T02.1.3, validation T02.1.4)

---

### RISK 9: Audit Log Becomes Too Large

**Issue:** Over time, audit_log table could grow unbounded if logging every import event.

**Probability:** LOW (not an issue for E02, but long-term concern)

**Impact:** LOW (disk space, query slowdown in future)

**Mitigation:**
- Log import events (one per document), not every parser step
- Add retention policy: delete logs older than 90 days (future task)
- For E02 scope: accept logs accumulate; plan cleanup in E06 or later
- Implementation: One INSERT per document, not per module call

**Owner:** DEV-024 (design import logging strategy, T02.1.3)

---

## Risk Summary

| # | Risk | Probability | Impact | Mitigation |
|---|------|-------------|--------|-----------|
| 1 | Large PDF timeout | MEDIUM | MEDIUM | File size check, longer timeout |
| 2 | Memory leak | LOW | HIGH | Context managers, psutil monitoring |
| 3 | SQLite lock | MEDIUM | MEDIUM | Enable WAL mode |
| 4 | Corrupted DOCX | MEDIUM | MEDIUM | Try/except handling |
| 5 | Hash collision | NEGLIGIBLE | HIGH | Use SHA-256 (already sufficient) |
| 6 | Schema missing | LOW | HIGH | Explicit dependency, startup check |
| 7 | Unsupported file | MEDIUM | LOW | Whitelist extensions |
| 8 | Performance miss | MEDIUM | MEDIUM | Benchmark, tune if needed |
| 9 | Audit log bloat | LOW | LOW | Logging strategy, future cleanup |

---

## Critical Path Impact

**Blockers for T02.1.3 (Implementation):**
- ❌ T02.3.1 must complete first (schema must exist)

**Blockers for T02.1.4 (Testing):**
- ❌ T02.1.3 must complete first (code must exist to test)

**Non-Blockers (can start independently):**
- ✅ T02.2.1 (Dedup scoping)
- ✅ T02.3.1 (Schema design)
- ✅ T02.4.1 (Classification)

---

**Document Status:** Risk Assessment COMPLETE.  
**Next:** Implementation (T02.1.3) proceeds with risk mitigations in place.
