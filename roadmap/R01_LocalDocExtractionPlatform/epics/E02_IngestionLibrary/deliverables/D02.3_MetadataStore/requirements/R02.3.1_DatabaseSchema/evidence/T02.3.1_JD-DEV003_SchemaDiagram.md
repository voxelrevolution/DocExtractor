# Schema Diagram & Design: T02.3.1 Database Architecture

**Task:** T02.3.1_JD-DEV003_DesignSQLSchema  
**Evidence Artifact:** Schema Diagram & Entity Relationships  
**Created By:** DEV-003 (Database Developer)  
**Date:** 2026-01-14

---

## Executive Summary

PostgreSQL schema designed to support document ingestion, deduplication, classification, and tagging. 8 core tables with normalized structure, strategic indexing, and immutable audit trail. Scales to 1M+ documents, 100M+ audit records.

---

## Entity-Relationship Diagram (ERD)

```
┌─────────────────────────┐
│   import_batches        │
├─────────────────────────┤
│ id (PK)                 │
│ batch_time              │
│ import_source           │
│ import_user             │
│ doc_count               │
│ status                  │
└─────┬───────────────────┘
      │ 1
      │ (one-to-many)
      │
┌─────▼───────────────────────────────────────────────────────────┐
│   documents (CORE)                                              │
├─────────────────────────────────────────────────────────────────┤
│ id (PK, UUID)                                                   │
│ filename (NOT NULL)                                             │
│ file_size_bytes                                                 │
│ file_format (pdf, docx, image, etc.)                            │
│ sha256_hash (NOT NULL, UNIQUE)                                  │
│ import_batch_id (FK → import_batches)                           │
│ import_time (NOT NULL)                                          │
│ import_source_path                                              │
│ status (ENUM: new, duplicate, classified, tagged)              │
│ created_at, updated_at                                          │
└─────┬─────────┬──────────────┬──────────────┬───────────────────┘
      │         │              │              │
      │ 1:1     │ 1:N          │ 1:N          │ 1:N
      │         │              │              │
      │    ┌────▼──────────┐   │    ┌─────────▼────────┐
      │    │ document_     │   │    │ document_        │
      │    │ hashes        │   │    │ classifications  │
      │    ├───────────────┤   │    ├──────────────────┤
      │    │ id (PK)       │   │    │ id (PK)          │
      │    │ doc_id (FK)   │   │    │ doc_id (FK)      │
      │    │ hash          │   │    │ category         │
      │    │ is_duplicate  │   │    │ confidence       │
      │    │ first_seen    │   │    │ model_version    │
      │    │ duplicate_of_ │   │    │ classified_at    │
      │    │ doc_id        │   │    │ created_at       │
      │    └───────────────┘   │    └──────────────────┘
      │                        │
      └────────┬───────────────┘
               │ 1
               │ (one-to-many)
               │
        ┌──────▼──────────┐
        │ document_tags   │
        ├─────────────────┤
        │ id (PK)         │
        │ doc_id (FK)     │
        │ tag_id (FK)     │
        │ assigned_at     │
        │ assigned_by     │
        └──────┬──────────┘
               │ N
               │
        ┌──────▼──────────┐
        │ tags            │
        ├─────────────────┤
        │ id (PK)         │
        │ tag_name        │
        │ description     │
        │ created_by      │
        │ created_at      │
        └─────────────────┘

┌──────────────────────────────────────────────┐
│ audit_log (IMMUTABLE)                        │
├──────────────────────────────────────────────┤
│ id (PK, BIGINT, SEQUENCE)                    │
│ entity_type (ENUM: document, hash, class)   │
│ entity_id (UUID or similar)                  │
│ action (ENUM: insert, update, duplicate)    │
│ timestamp (NOT NULL)                         │
│ user_id                                      │
│ old_value (JSONB)                            │
│ new_value (JSONB)                            │
│ reason (TEXT, audit trail)                   │
│ created_at (immutable, never updated)        │
└──────────────────────────────────────────────┘
```

---

## Table Definitions

### 1. import_batches
**Purpose:** Track document import batches for traceability and bulk operations.

```
CREATE TABLE import_batches (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  batch_time TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  import_source VARCHAR(255) NOT NULL,
  import_user VARCHAR(255),
  doc_count INTEGER NOT NULL CHECK (doc_count >= 0),
  status VARCHAR(50) NOT NULL DEFAULT 'pending',
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

COMMENT ON TABLE import_batches IS 'Batch metadata for tracking document imports';
COMMENT ON COLUMN import_batches.id IS 'Unique batch identifier (UUID)';
COMMENT ON COLUMN import_batches.batch_time IS 'When the batch import started';
COMMENT ON COLUMN import_batches.import_source IS 'File path or system source of batch';
COMMENT ON COLUMN import_batches.status IS 'Batch status: pending, complete, failed';
```

### 2. documents (CORE)
**Purpose:** Core document table; one row per imported document.

```
CREATE TABLE documents (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  filename VARCHAR(512) NOT NULL,
  file_size_bytes BIGINT NOT NULL CHECK (file_size_bytes > 0),
  file_format VARCHAR(50) NOT NULL,
  sha256_hash VARCHAR(64) NOT NULL UNIQUE,
  import_batch_id UUID NOT NULL REFERENCES import_batches(id),
  import_time TIMESTAMPTZ NOT NULL,
  import_source_path TEXT,
  status VARCHAR(50) NOT NULL DEFAULT 'new',
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_documents_batch ON documents(import_batch_id);
CREATE INDEX idx_documents_import_time ON documents(import_time);
CREATE INDEX idx_documents_status ON documents(status);

COMMENT ON TABLE documents IS 'Core document records; one per imported file';
COMMENT ON COLUMN documents.sha256_hash IS 'SHA-256 hash for deduplication (UNIQUE ensures zero duplicates)';
COMMENT ON COLUMN documents.status IS 'Document status: new, duplicate, classified, tagged, archived';
```

### 3. document_hashes
**Purpose:** Deduplication tracking; immutable record of hash and duplicate status.

```
CREATE TABLE document_hashes (
  id BIGSERIAL PRIMARY KEY,
  doc_id UUID NOT NULL UNIQUE REFERENCES documents(id),
  hash VARCHAR(64) NOT NULL,
  is_duplicate BOOLEAN NOT NULL DEFAULT FALSE,
  first_seen TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  duplicate_of_doc_id UUID REFERENCES documents(id),
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE UNIQUE INDEX idx_hash_lookup ON document_hashes(hash);
CREATE INDEX idx_duplicate_status ON document_hashes(is_duplicate);

COMMENT ON TABLE document_hashes IS 'Immutable record of document hashes and dedup status';
COMMENT ON COLUMN document_hashes.hash IS 'SHA-256 hash (UNIQUE index for < 10ms lookups)';
COMMENT ON COLUMN document_hashes.is_duplicate IS 'TRUE if document is a duplicate of an earlier import';
```

### 4. document_classifications
**Purpose:** Track classification results (category + confidence) per document.

```
CREATE TABLE document_classifications (
  id BIGSERIAL PRIMARY KEY,
  doc_id UUID NOT NULL REFERENCES documents(id),
  category VARCHAR(100) NOT NULL,
  confidence DECIMAL(3,2) NOT NULL CHECK (confidence >= 0 AND confidence <= 1),
  model_version VARCHAR(50),
  classified_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  UNIQUE(doc_id, category, model_version)
);

CREATE INDEX idx_classification_category ON document_classifications(category);
CREATE INDEX idx_classification_doc ON document_classifications(doc_id);

COMMENT ON TABLE document_classifications IS 'Document classification results per taxonomy category';
COMMENT ON COLUMN document_classifications.confidence IS 'Confidence score [0,1]; e.g., 0.95 = 95% confidence';
```

### 5. tags
**Purpose:** Define user-created tags for organization.

```
CREATE TABLE tags (
  id BIGSERIAL PRIMARY KEY,
  tag_name VARCHAR(100) NOT NULL UNIQUE,
  description TEXT,
  created_by VARCHAR(255),
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

COMMENT ON TABLE tags IS 'User-defined tags for document organization';
COMMENT ON COLUMN tags.tag_name IS 'Tag name (UNIQUE); e.g., "invoice", "confidential"';
```

### 6. document_tags (BRIDGE TABLE)
**Purpose:** Many-to-many relationship between documents and tags.

```
CREATE TABLE document_tags (
  id BIGSERIAL PRIMARY KEY,
  doc_id UUID NOT NULL REFERENCES documents(id) ON DELETE CASCADE,
  tag_id BIGINT NOT NULL REFERENCES tags(id),
  assigned_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  assigned_by VARCHAR(255),
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  UNIQUE(doc_id, tag_id)
);

CREATE INDEX idx_tag_lookup ON document_tags(tag_id, doc_id);
CREATE INDEX idx_doc_tags ON document_tags(doc_id);

COMMENT ON TABLE document_tags IS 'Bridge table for many-to-many document-tag relationships';
```

### 7. audit_log (IMMUTABLE APPEND-ONLY)
**Purpose:** Immutable audit trail for compliance and traceability.

```
CREATE TABLE audit_log (
  id BIGSERIAL PRIMARY KEY,
  entity_type VARCHAR(50) NOT NULL,
  entity_id VARCHAR(255) NOT NULL,
  action VARCHAR(50) NOT NULL,
  timestamp TIMESTAMPTZ NOT NULL,
  user_id VARCHAR(255),
  old_value JSONB,
  new_value JSONB,
  reason TEXT,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_audit_entity ON audit_log(entity_type, entity_id, timestamp);
CREATE INDEX idx_audit_action ON audit_log(action);
CREATE INDEX idx_audit_time ON audit_log(timestamp);

COMMENT ON TABLE audit_log IS 'Immutable audit trail; append-only, no updates';
COMMENT ON COLUMN audit_log.entity_type IS 'What was audited: "document", "hash", "classification", "tag"';
COMMENT ON COLUMN audit_log.action IS 'What happened: "import", "duplicate_detected", "classified", "tagged"';
```

---

## Key Design Decisions

### 1. UUID Primary Keys (Documents)
- **Why:** Distributed generation, no sequential guessing, natural sharding key
- **Benefit:** Security (no predictable IDs), distributed scaling

### 2. UNIQUE Index on hash (document_hashes)
- **Why:** Enforce deduplication at database level; < 10ms lookup
- **Benefit:** Zero false negatives; query planner uses index for exact match

### 3. BIGSERIAL for Audit Log
- **Why:** Very large sequential values (100M+ rows expected)
- **Benefit:** Scalability; no UUID collision overhead for append-only table

### 4. Immutable Audit Trail Pattern
- **Why:** Compliance, traceability, no data loss
- **Benefit:** Historical records never modified; forensic capability

### 5. Bridge Table for Tags (document_tags)
- **Why:** Many-to-many relationship flexibility
- **Benefit:** Add/remove tags without modifying documents table

### 6. JSONB for Old/New Values in Audit Log
- **Why:** Flexible schema; capture any field changes
- **Benefit:** Future-proof audit trail; no schema changes needed for new fields

---

## Performance Targets & Justification

| Operation | Target | Index Strategy | Expected Performance |
|-----------|--------|-----------------|----------------------|
| Hash lookup (dedup check) | < 10ms | UNIQUE idx on hash | Direct index hit, single row |
| Batch import (per doc) | < 1.2s | Composite idx on (batch_id, created_at) | Insert + index update + fk check |
| Dedup reporting (batch stats) | < 500ms | Composite idx on (is_duplicate, batch_id) | Table scan w/ filter, aggregation |
| Classification update | < 100ms | Idx on doc_id, category | Insert + unique constraint check |
| Tag assignment | < 50ms | Idx on document_tags(doc_id, tag_id) | Insert + fk checks |
| Audit query (compliance) | < 1s | Composite idx (entity_type, timestamp) | Range scan + filtering |

---

## Scalability Assumptions

| Metric | Scale | Strategy |
|--------|-------|----------|
| Documents | 1M+ | Keep in main table; index efficiently |
| Audit Log Rows | 100M+ | Partition by year (audit_log_2024, audit_log_2025, etc.) |
| Storage (documents) | ~100GB | ~100KB per document (metadata + hash) |
| Storage (audit_log) | ~10GB | ~100 bytes per audit record |
| Archive Strategy | Documents > 7y | Move to audit_log_archive partition (quarterly review) |

---

## Schema Constraints Summary

| Constraint Type | Example | Enforces |
|-----------------|---------|----------|
| PRIMARY KEY | documents.id | Uniqueness, fast lookups |
| UNIQUE | documents.sha256_hash | Zero duplicate hashes |
| FOREIGN KEY | documents.import_batch_id → import_batches.id | Referential integrity |
| NOT NULL | documents.filename, documents.import_time | Required fields |
| CHECK | file_size_bytes > 0, confidence ∈ [0,1] | Valid data ranges |
| UNIQUE (composite) | (doc_id, tag_id) in document_tags | No duplicate tag assignments |

---

## Integration Points

### With D02.1 (Import Engine)
- **Input:** Filename, file_size_bytes, file_format, sha256_hash, import_batch_id, import_time
- **Output:** documents table populated; audit_log records created for each import

### With D02.2 (Deduplication)
- **Input:** SHA-256 hash from document (via D02.1)
- **Lookup:** SELECT * FROM document_hashes WHERE hash = ?  (< 10ms)
- **Output:** is_duplicate flag set; duplicate_of_doc_id populated if duplicate

### With D02.4 (Classification)
- **Input:** doc_id, category, confidence, model_version
- **Output:** document_classifications row inserted; status updated

### With D02.5 (Tagging)
- **Input:** doc_id, tag_id
- **Output:** document_tags row inserted; audit_log record created

---

## Related Documents

- **Data Dictionary:** T02.3.1_JD-DEV003_DataDictionary.md (column-level details)
- **Normalization Analysis:** T02.3.1_JD-DEV003_NormalizationAnalysis.md (3NF justification)
- **Indexing Strategy:** T02.3.1_JD-DEV003_IndexingStrategy.md (performance optimization)
- **DDL Statements:** T02.3.1_JD-DEV003_DDLStatements.md (ready-to-deploy SQL)

---

**Document Status:** Schema diagram complete and ready for implementation.
